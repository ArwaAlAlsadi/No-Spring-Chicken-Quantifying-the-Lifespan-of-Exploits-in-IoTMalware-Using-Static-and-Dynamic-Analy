import os
import csv
import time
import argparse

import regex

CURR_DIR = os.path.dirname(__file__)

SYMBOLS = ["+", "?", "[", "]", "{", "}", "$", "|"]
IN_HEADERS = [
    "Signatures",
    "Vulnerability CVE",
    "Vulnerability Publish Date",
    "Type of Vulnerability",
    "Device Manufacturing",
    "Targeted Device",
    "Exploit Publish Date",
    "Exploit Example"
]
OUT_HEADERS = ["ID", "Text"] + IN_HEADERS

def load_csv(path):
    """Loads csv file from path, returns a list of rows as dictionaries.""" 
    try:
        with open(path, newline="") as f:
            return list(csv.DictReader(f))
    except FileNotFoundError:
        print(f"File {path} not found.")
        return

def get_output_filename():
    """Returns a formatted output filename cointaing UNIX timestamp."""
    return os.path.join(CURR_DIR, "ExploitMatch.csv")

def get_csv_writer(path):
    f = open(path, "w", newline="")
    writer = csv.DictWriter(f, fieldnames=OUT_HEADERS)
    writer.writeheader()
    
    return f, writer

def format_text(text, pd, max_length=70):
    """Pads text longer than max_lenght."""
    if len(text) > max_length:
        return ("\n" + pd + " " * 11).join(
            [text[i:i+max_length] for i in range(0, len(text), max_length)])

    return text

def escape_pattern(pattern, *symbols):
    """Escapes given symbols in pattern string."""
    for symbol in symbols:
        pattern = pattern.replace(symbol, f"\{symbol}")

    return pattern

def write_row(writer, vuln_data, key_data):
    """Fills in one row of the output csv."""
    data = {**vuln_data, **key_data}


    writer.writerow(data)

def get_keywords_map(data):
    """
    Preprocesses keywords in order to handle tagged variables,
    returns a dict version of the data, mapping each keyword
    to its row of origin.
    """
    data_map = {}
    for i, data in enumerate(data):
        # Handling '+' sign
        for k in data["Keywords"].split("\n+\n"):
            # Replacing <> tagged variables with unique sequence of chars
            k = regex.sub('\"<.*>\"', "~^~", k)
            data_map[k] = i
    
    return data_map

def run(vuln_data, keywords_data):
    """Runs the matching loop."""
    # Calculate vars to format log 
    vuln_len = len(vuln_data)
    f_len = len(str(vuln_len))
    padding = " " * (f_len * 2 + 4)

    keywords_map = get_keywords_map(keywords_data)
    out_filename = get_output_filename()
    out_file, vuln_writer = get_csv_writer(out_filename)

    matches = 0
    c = 0
    for row in vuln_data:
        text = row["Text"]

        print(f"\n[{c:0>{f_len}d}/{vuln_len}]"
            f" Analyzing '{format_text(text, padding)}'")
        print(padding, end="") 

        c += 1
        match = False
        for keyword in keywords_map:
            # Escaping '*' and '.'
            key = keyword.replace("*", "\*")
            key = key.replace(".", "\.")
            # Replacing previously subsituted tagged variables
            # with regex syntax
            splitted = key.split("~^~")
            if len(splitted) > 1:
                pattern = ""
                for split in splitted:
                    pattern += split + "(.*)"
                pattern = pattern[:-4]
            else:
                pattern = key

            pattern = escape_pattern(pattern, *SYMBOLS)
            # Appending {e} to handle fuzzy matching
            pattern += "{e}"

            m = regex.search(pattern, text)
            if m:
                # Getting keyword's dict of origin
                og_key_data = keywords_data[keywords_map[keyword]]
                og_keyword = og_key_data["Keywords"].replace("\n", "\\n")
                print(f"FOUND pattern '{pattern[:-3]}'\n" +
                    padding + f"from keyword '{og_keyword}'")

                write_row(vuln_writer, row, og_key_data)

                matches += 1
                match = True
                break

        if not match:
            print("No match.")

    out_file.close()
    print(f"\nMatches: {matches}/{len(vuln_data)}")
    print(f"Output saved as {out_filename}")

def main():
    parser = argparse.ArgumentParser(
        description="Matches vulnerabilities keywords from csv keywords_file "
                    "to text reports in csv file_to_fill")
    parser.add_argument("file_to_fill",
        help="csv file with filled ID and Text columns (csv1)")
    parser.add_argument("keywords_file",
        help="csv file containing vulnerabilities keywords (csv2)")

    args = parser.parse_args()

    keywords_data = load_csv(args.keywords_file)
    vuln_data = load_csv(args.file_to_fill)

    if vuln_data and keywords_data:
        run(vuln_data, keywords_data)

if __name__ == "__main__":
    main()

